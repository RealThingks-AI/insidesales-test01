import { useState, useEffect, useMemo, forwardRef, useImperativeHandle } from "react";
import { useSearchParams } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { useCRUDAudit } from "@/hooks/useCRUDAudit";
import { useUserDisplayNames } from "@/hooks/useUserDisplayNames";
import { useColumnPreferences } from "@/hooks/useColumnPreferences";
import { Card } from "@/components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Search, ArrowUpDown, ArrowUp, ArrowDown, ChevronLeft, ChevronRight, X, Eye, Building2 } from "lucide-react";
import { RowActionsDropdown, Edit, Trash2, Mail } from "./RowActionsDropdown";
import { AccountModal } from "./AccountModal";
import { AccountColumnCustomizer, AccountColumnConfig, defaultAccountColumns } from "./AccountColumnCustomizer";
import { AccountStatusFilter } from "./AccountStatusFilter";
import { AccountDeleteConfirmDialog } from "./AccountDeleteConfirmDialog";
import { SendEmailModal, EmailRecipient } from "./SendEmailModal";
import { AccountDetailModal } from "./accounts/AccountDetailModal";
import { HighlightedText } from "./shared/HighlightedText";
import { ClearFiltersButton } from "./shared/ClearFiltersButton";
import { TableSkeleton } from "./shared/Skeletons";
import { useQuery } from "@tanstack/react-query";

// Export ref interface for parent component
export interface AccountTableRef {
  handleBulkDelete: () => Promise<void>;
}
export interface Account {
  id: string;
  company_name: string;
  region?: string;
  country?: string;
  website?: string;
  company_type?: string;
  tags?: string[];
  status?: string;
  notes?: string;
  account_owner?: string;
  industry?: string;
  phone?: string;
  email?: string;
  created_at?: string;
  updated_at?: string;
  created_by?: string;
  modified_by?: string;
  score?: number;
  segment?: string;
  total_revenue?: number;
  deal_count?: number;
  contact_count?: number;
}
interface AccountTableProps {
  showColumnCustomizer: boolean;
  setShowColumnCustomizer: (show: boolean) => void;
  showModal: boolean;
  setShowModal: (show: boolean) => void;
  selectedAccounts: string[];
  setSelectedAccounts: React.Dispatch<React.SetStateAction<string[]>>;
  onBulkDeleteComplete?: () => void;
  initialStatus?: string;
}
const PAGE_SIZE_OPTIONS = [10, 25, 50, 100];
const AccountTable = forwardRef<AccountTableRef, AccountTableProps>(({
  showColumnCustomizer,
  setShowColumnCustomizer,
  showModal,
  setShowModal,
  selectedAccounts,
  setSelectedAccounts,
  onBulkDeleteComplete,
  initialStatus = "all"
}, ref) => {
  const {
    toast
  } = useToast();
  const {
    logDelete
  } = useCRUDAudit();
  const [searchParams, setSearchParams] = useSearchParams();
  const [accounts, setAccounts] = useState<Account[]>([]);
  const [filteredAccounts, setFilteredAccounts] = useState<Account[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState(initialStatus);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  // Column preferences hook
  const {
    columns,
    saveColumns,
    isSaving
  } = useColumnPreferences({
    moduleName: 'accounts',
    defaultColumns: defaultAccountColumns
  });
  const [localColumns, setLocalColumns] = useState<AccountColumnConfig[]>(columns);

  // Sync local columns when saved columns change
  useEffect(() => {
    setLocalColumns(columns);
  }, [columns]);

  // Get owner parameter from URL - "me" means filter by current user
  const ownerParam = searchParams.get('owner');
  const [ownerFilter, setOwnerFilter] = useState<string>("all");
  const [tagFilter, setTagFilter] = useState<string | null>(null);

  // Fetch current user ID for "me" filtering
  useEffect(() => {
    const fetchCurrentUser = async () => {
      const {
        data: {
          user
        }
      } = await supabase.auth.getUser();
      if (user) {
        setCurrentUserId(user.id);
        // If owner=me in URL, set the owner filter to current user's ID
        if (ownerParam === 'me') {
          setOwnerFilter(user.id);
        }
      }
    };
    fetchCurrentUser();
  }, [ownerParam]);

  // Sync statusFilter when initialStatus prop changes (from URL)
  useEffect(() => {
    setStatusFilter(initialStatus);
  }, [initialStatus]);

  // Sync ownerFilter when ownerParam changes
  useEffect(() => {
    if (ownerParam === 'me' && currentUserId) {
      setOwnerFilter(currentUserId);
    } else if (!ownerParam) {
      setOwnerFilter('all');
    }
  }, [ownerParam, currentUserId]);
  const [editingAccount, setEditingAccount] = useState<Account | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [accountToDelete, setAccountToDelete] = useState<Account | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(25);
  const [sortField, setSortField] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');
  const [emailModalOpen, setEmailModalOpen] = useState(false);
  const [emailRecipient, setEmailRecipient] = useState<EmailRecipient | null>(null);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [viewingAccount, setViewingAccount] = useState<Account | null>(null);
  const [isBulkDeleting, setIsBulkDeleting] = useState(false);

  // Handle viewId from URL (from global search)
  const viewId = searchParams.get('viewId');
  useEffect(() => {
    if (viewId && accounts.length > 0) {
      const accountToView = accounts.find(a => a.id === viewId);
      if (accountToView) {
        setViewingAccount(accountToView);
        setShowDetailModal(true);
        // Clear the viewId from URL after opening
        setSearchParams(prev => {
          prev.delete('viewId');
          return prev;
        }, {
          replace: true
        });
      }
    }
  }, [viewId, accounts, setSearchParams]);

  // Expose handleBulkDelete to parent via ref
  useImperativeHandle(ref, () => ({
    handleBulkDelete
  }), [selectedAccounts, accounts]);

  // Fetch all profiles for owner dropdown
  const {
    data: allProfiles = []
  } = useQuery({
    queryKey: ['all-profiles'],
    queryFn: async () => {
      const {
        data
      } = await supabase.from('profiles').select('id, full_name');
      return data || [];
    }
  });
  useEffect(() => {
    fetchAccounts();
  }, []);
  useEffect(() => {
    const searchLower = searchTerm.toLowerCase();
    let filtered = accounts.filter(account => account.company_name?.toLowerCase().includes(searchLower) || account.industry?.toLowerCase().includes(searchLower) || account.country?.toLowerCase().includes(searchLower) || account.email?.toLowerCase().includes(searchLower) || account.phone?.toLowerCase().includes(searchLower) || account.website?.toLowerCase().includes(searchLower) || account.notes?.toLowerCase().includes(searchLower) || account.company_type?.toLowerCase().includes(searchLower) || account.region?.toLowerCase().includes(searchLower) || account.segment?.toLowerCase().includes(searchLower) || account.tags?.some(tag => tag.toLowerCase().includes(searchLower)));
    if (statusFilter !== "all") {
      filtered = filtered.filter(account => account.status === statusFilter);
    }

    // FIX: Use account_owner instead of created_by for owner filtering
    if (ownerFilter !== "all") {
      filtered = filtered.filter(account => account.account_owner === ownerFilter);
    }
    if (tagFilter) {
      filtered = filtered.filter(account => account.tags?.includes(tagFilter));
    }
    if (sortField) {
      filtered.sort((a, b) => {
        const aValue = a[sortField as keyof Account] || '';
        const bValue = b[sortField as keyof Account] || '';

        // Handle numeric sorting for score, revenue, counts
        if (typeof aValue === 'number' && typeof bValue === 'number') {
          return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
        }
        const comparison = aValue.toString().localeCompare(bValue.toString());
        return sortDirection === 'asc' ? comparison : -comparison;
      });
    }
    setFilteredAccounts(filtered);
    setCurrentPage(1);
  }, [accounts, searchTerm, statusFilter, ownerFilter, tagFilter, sortField, sortDirection]);
  const handleSort = (field: string) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };
  const getSortIcon = (field: string) => {
    return null; // Hide sort icons but keep sorting on click
  };
  const fetchAccounts = async () => {
    try {
      setLoading(true);
      const {
        data: accountsData,
        error
      } = await supabase.from('accounts').select('*').order('created_at', {
        ascending: false
      });
      if (error) throw error;

      // Fetch actual contact counts per account
      const { data: contactCounts } = await supabase
        .from('contacts')
        .select('account_id')
        .not('account_id', 'is', null);

      // Calculate contact counts
      const contactCountMap = (contactCounts || []).reduce((acc, c) => {
        if (c.account_id) {
          acc[c.account_id] = (acc[c.account_id] || 0) + 1;
        }
        return acc;
      }, {} as Record<string, number>);

      // Merge actual counts into accounts
      const accountsWithCounts = (accountsData || []).map(account => ({
        ...account,
        contact_count: contactCountMap[account.id] || 0,
      }));

      setAccounts(accountsWithCounts);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to fetch accounts",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };
  const handleDelete = async () => {
    if (!accountToDelete?.id) return;
    try {
      // Check for linked contacts/leads
      const {
        data: linkedContacts
      } = await supabase.from('contacts').select('id').eq('account_id', accountToDelete.id).limit(1);
      const {
        data: linkedLeads
      } = await supabase.from('leads').select('id').eq('account_id', accountToDelete.id).limit(1);
      if (linkedContacts && linkedContacts.length > 0 || linkedLeads && linkedLeads.length > 0) {
        toast({
          title: "Cannot Delete",
          description: "This account has linked contacts or leads. Please unlink them first.",
          variant: "destructive"
        });
        setShowDeleteDialog(false);
        return;
      }
      const {
        error
      } = await supabase.from('accounts').delete().eq('id', accountToDelete.id);
      if (error) throw error;
      await logDelete('accounts', accountToDelete.id, accountToDelete);
      toast({
        title: "Success",
        description: "Account deleted successfully"
      });
      fetchAccounts();
      setAccountToDelete(null);
      setShowDeleteDialog(false);
    } catch (error: any) {
      toast({
        title: "Error",
        description: error.message || "Failed to delete account",
        variant: "destructive"
      });
    }
  };

  // Bulk delete handler
  const handleBulkDelete = async () => {
    if (selectedAccounts.length === 0) return;
    setIsBulkDeleting(true);
    try {
      // Check for linked entities for all selected accounts
      const {
        data: linkedContacts
      } = await supabase.from('contacts').select('account_id').in('account_id', selectedAccounts);
      const {
        data: linkedLeads
      } = await supabase.from('leads').select('account_id').in('account_id', selectedAccounts);
      const accountsWithLinks = new Set([...(linkedContacts || []).map(c => c.account_id), ...(linkedLeads || []).map(l => l.account_id)]);
      const deletableAccounts = selectedAccounts.filter(id => !accountsWithLinks.has(id));
      const skippedCount = selectedAccounts.length - deletableAccounts.length;
      if (deletableAccounts.length === 0) {
        toast({
          title: "Cannot Delete",
          description: "All selected accounts have linked contacts or leads.",
          variant: "destructive"
        });
        setIsBulkDeleting(false);
        return;
      }
      const {
        error
      } = await supabase.from('accounts').delete().in('id', deletableAccounts);
      if (error) throw error;

      // Log deletions
      for (const id of deletableAccounts) {
        const account = accounts.find(a => a.id === id);
        if (account) {
          await logDelete('accounts', id, account);
        }
      }
      toast({
        title: "Success",
        description: skippedCount > 0 ? `Deleted ${deletableAccounts.length} accounts. ${skippedCount} skipped (have linked records).` : `Deleted ${deletableAccounts.length} accounts successfully`
      });
      setSelectedAccounts([]);
      fetchAccounts();
      onBulkDeleteComplete?.();
    } catch (error: any) {
      toast({
        title: "Error",
        description: error.message || "Failed to delete accounts",
        variant: "destructive"
      });
    } finally {
      setIsBulkDeleting(false);
    }
  };
  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      const pageAccounts = getCurrentPageAccounts().slice(0, 50);
      setSelectedAccounts(pageAccounts.map(a => a.id));
    } else {
      setSelectedAccounts([]);
    }
  };
  const handleSelectAccount = (accountId: string, checked: boolean) => {
    if (checked) {
      setSelectedAccounts(prev => [...prev, accountId]);
    } else {
      setSelectedAccounts(prev => prev.filter(id => id !== accountId));
    }
  };
  const getCurrentPageAccounts = () => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    return filteredAccounts.slice(startIndex, startIndex + itemsPerPage);
  };
  const totalPages = Math.ceil(filteredAccounts.length / itemsPerPage);

  // Get owner IDs for display names - use account_owner instead of created_by
  const ownerIds = useMemo(() => {
    return [...new Set(accounts.map(a => a.account_owner).filter(Boolean))];
  }, [accounts]);
  const {
    displayNames
  } = useUserDisplayNames(ownerIds);
  const visibleColumns = localColumns.filter(col => col.visible);
  const pageAccounts = getCurrentPageAccounts();

  // Check if any filters are active
  const hasActiveFilters = searchTerm !== "" || statusFilter !== "all" || ownerFilter !== "all" || tagFilter !== null;
  const clearAllFilters = () => {
    setSearchTerm("");
    setStatusFilter("all");
    setOwnerFilter("all");
    setTagFilter(null);
  };
  const getStatusBadgeClasses = (status?: string) => {
    switch (status) {
      case 'Hot':
        return 'bg-rose-50 text-rose-700 dark:bg-rose-900/20 dark:text-rose-300 border-rose-200 dark:border-rose-800';
      case 'Warm':
        return 'bg-amber-50 text-amber-700 dark:bg-amber-900/20 dark:text-amber-300 border-amber-200 dark:border-amber-800';
      case 'Working':
        return 'bg-blue-50 text-blue-700 dark:bg-blue-900/20 dark:text-blue-300 border-blue-200 dark:border-blue-800';
      case 'Nurture':
        return 'bg-indigo-50 text-indigo-700 dark:bg-indigo-900/20 dark:text-indigo-300 border-indigo-200 dark:border-indigo-800';
      case 'Closed-Won':
        return 'bg-emerald-50 text-emerald-700 dark:bg-emerald-900/20 dark:text-emerald-300 border-emerald-200 dark:border-emerald-800';
      case 'Closed-Lost':
        return 'bg-gray-100 text-gray-600 dark:bg-gray-800/30 dark:text-gray-400 border-gray-200 dark:border-gray-700';
      case 'New':
        return 'bg-slate-100 text-slate-700 dark:bg-slate-800/30 dark:text-slate-300 border-slate-200 dark:border-slate-700';
      default:
        return 'bg-muted text-muted-foreground border-border';
    }
  };

  // Generate initials from company name
  const getCompanyInitials = (name: string) => {
    return name.split(' ').slice(0, 2).map(word => word.charAt(0).toUpperCase()).join('');
  };

  // Generate consistent color from company name
  const getAvatarColor = (name: string) => {
    const colors = ['bg-slate-500', 'bg-slate-600', 'bg-zinc-500', 'bg-gray-500', 'bg-stone-500', 'bg-neutral-500', 'bg-slate-700', 'bg-zinc-600'];
    const index = name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % colors.length;
    return colors[index];
  };
  const formatCurrency = (value?: number): React.ReactNode => {
    if (!value) return <span className="block text-center w-full">-</span>;
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      notation: 'compact',
      maximumFractionDigits: 1
    }).format(value);
  };
  return <div className="flex flex-col h-full space-y-3">
      {/* Header and Actions */}
      <div className="flex items-center justify-between gap-4 flex-wrap">
        <div className="flex items-center gap-3 flex-wrap">
          <div className="relative w-64">
            <Search className="absolute left-2.5 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
            <Input placeholder="Search accounts..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="pl-9" inputSize="control" />
          </div>
          <AccountStatusFilter value={statusFilter} onValueChange={setStatusFilter} />
          <Select value={ownerFilter} onValueChange={setOwnerFilter}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="All Owners" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Owners</SelectItem>
              {allProfiles.map(profile => <SelectItem key={profile.id} value={profile.id}>
                  {profile.full_name || 'Unknown'}
                </SelectItem>)}
            </SelectContent>
          </Select>
          
          {tagFilter && <Badge variant="secondary" className="flex items-center gap-1">
              Tag: {tagFilter}
              <button onClick={() => setTagFilter(null)} className="ml-1 hover:text-destructive">
                <X className="w-3 h-3" />
              </button>
            </Badge>}
          
          <ClearFiltersButton hasActiveFilters={hasActiveFilters} onClear={clearAllFilters} />
        </div>
        
        {/* Page size selector */}
        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground">Show:</span>
          <Select value={itemsPerPage.toString()} onValueChange={val => setItemsPerPage(Number(val))}>
            <SelectTrigger className="w-[70px] h-8">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {PAGE_SIZE_OPTIONS.map(size => <SelectItem key={size} value={size.toString()}>{size}</SelectItem>)}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Table */}
      <Card className="flex-1 min-h-0 flex flex-col">
        <div className="relative overflow-auto flex-1">
          <Table>
            <TableHeader>
              <TableRow className="sticky top-0 z-20 bg-muted border-b-2">
                <TableHead className="w-12 text-center font-bold text-foreground">
                  <div className="flex justify-center">
                    <Checkbox checked={selectedAccounts.length > 0 && selectedAccounts.length === Math.min(pageAccounts.length, 50)} onCheckedChange={handleSelectAll} />
                  </div>
                </TableHead>
                {visibleColumns.map(column => <TableHead key={column.field} className="text-left font-bold text-foreground px-4 py-3 whitespace-nowrap">
                    <div onClick={() => handleSort(column.field)} className="group gap-2 cursor-pointer hover:text-primary flex items-center justify-center">
                      {column.label}
                      {getSortIcon(column.field)}
                    </div>
                  </TableHead>)}
                <TableHead className="text-center font-bold text-foreground w-32 px-4 py-3">
                  Actions
                </TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {loading ? <TableRow>
                  <TableCell colSpan={visibleColumns.length + 2} className="p-0">
                    <TableSkeleton columns={visibleColumns.length + 2} rows={10} />
                  </TableCell>
                </TableRow> : pageAccounts.length === 0 ? <TableRow>
                  <TableCell colSpan={visibleColumns.length + 2} className="text-center py-8">
                    <div className="flex flex-col items-center gap-2 text-muted-foreground">
                      <Building2 className="w-10 h-10 opacity-50" />
                      <p>No accounts found</p>
                      {hasActiveFilters && <Button variant="link" size="sm" onClick={clearAllFilters}>
                          Clear filters
                        </Button>}
                    </div>
                  </TableCell>
                </TableRow> : pageAccounts.map(account => <TableRow key={account.id} className="hover:bg-muted/20 border-b group" data-state={selectedAccounts.includes(account.id) ? "selected" : undefined}>
                    <TableCell className="text-center px-4 py-3">
                      <div className="flex justify-center">
                        <Checkbox checked={selectedAccounts.includes(account.id)} onCheckedChange={checked => handleSelectAccount(account.id, checked as boolean)} />
                      </div>
                    </TableCell>
                    {visibleColumns.map(column => <TableCell key={column.field} className="text-left px-4 py-3 align-middle whitespace-nowrap overflow-hidden text-ellipsis max-w-[200px]">
                        {column.field === 'company_name' ? <button onClick={() => {
                    setViewingAccount(account);
                    setShowDetailModal(true);
                  }} className="text-primary hover:underline font-medium text-left truncate">
                              <HighlightedText text={account.company_name} highlight={searchTerm} />
                            </button> : column.field === 'account_owner' ? <span className="truncate block">
                            {account.account_owner ? displayNames[account.account_owner] || "Loading..." : <span className="block text-center w-full">-</span>}
                          </span> : column.field === 'status' ? (account.status ? <Badge variant="outline" className={`whitespace-nowrap ${getStatusBadgeClasses(account.status)}`}>
                            {account.status}
                          </Badge> : <span className="block text-center w-full">-</span>) : column.field === 'score' ? <span className={`font-medium text-center block w-full ${(account.score || 0) >= 70 ? 'text-green-600 dark:text-green-400' : (account.score || 0) >= 40 ? 'text-amber-600 dark:text-amber-400' : 'text-muted-foreground'}`}>
                            {account.score ?? '-'}
                          </span> : column.field === 'segment' ? account.segment ? <Badge variant="outline" className="text-xs">
                              {account.segment}
                            </Badge> : <span className="block text-center w-full">-</span> : column.field === 'total_revenue' ? <span className="font-medium">{formatCurrency(account.total_revenue)}</span> : column.field === 'deal_count' ? <span className="block text-center w-full">{account.deal_count ?? 0}</span> : column.field === 'contact_count' ? <span className="block text-center w-full">{account.contact_count ?? 0}</span> : column.field === 'tags' ? (account.tags && account.tags.length > 0 ? <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <div className="flex items-center gap-1">
                                  <Badge variant="outline" className="text-xs truncate max-w-[100px] cursor-pointer hover:bg-primary hover:text-primary-foreground transition-colors" onClick={() => setTagFilter(account.tags![0])}>
                                    {account.tags[0]}
                                  </Badge>
                                  {account.tags.length > 1 && <Badge variant="outline" className="text-xs shrink-0">
                                      +{account.tags.length - 1}
                                    </Badge>}
                                </div>
                              </TooltipTrigger>
                              <TooltipContent side="bottom" className="z-50">
                                <div className="flex flex-col gap-1">
                                  <span className="font-medium text-xs">All tags:</span>
                                  <div className="flex flex-wrap gap-1 max-w-[280px]">
                                    {account.tags.map((tag, idx) => <Badge key={idx} variant="secondary" className="text-xs cursor-pointer" onClick={() => setTagFilter(tag)}>
                                        {tag}
                                      </Badge>)}
                                  </div>
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider> : <span className="block text-center w-full">-</span>) : column.field === 'website' ? (account.website ? <a href={account.website.startsWith('http') ? account.website : `https://${account.website}`} target="_blank" rel="noopener noreferrer" className="text-primary hover:underline flex items-center gap-1">
                            <span className="truncate max-w-[150px]">
                              {account.website.replace(/^https?:\/\//, '')}
                            </span>
                          </a> : <span className="block text-center w-full">-</span>) : column.field === 'industry' ? <HighlightedText text={account.industry} highlight={searchTerm} /> : column.field === 'country' ? <HighlightedText text={account.country} highlight={searchTerm} /> : column.field === 'email' ? <HighlightedText text={account.email} highlight={searchTerm} className="text-center" /> : <span title={account[column.field as keyof Account]?.toString() || '-'} className="truncate block text-center">
                            {account[column.field as keyof Account]?.toString() || <span className="block text-center w-full">-</span>}
                          </span>}
                      </TableCell>)}
                    <TableCell className="w-20 px-4 py-3">
                      <div className="flex items-center justify-center gap-1">
                        <RowActionsDropdown actions={[{
                    label: "View",
                    icon: <Eye className="w-4 h-4" />,
                    onClick: () => {
                      setViewingAccount(account);
                      setShowDetailModal(true);
                    }
                  }, {
                    label: "Edit",
                    icon: <Edit className="w-4 h-4" />,
                    onClick: () => {
                      setEditingAccount(account);
                      setShowModal(true);
                    }
                  }, ...(account.email ? [{
                    label: "Send Email",
                    icon: <Mail className="w-4 h-4" />,
                    onClick: () => {
                      setEmailRecipient({
                        name: account.company_name,
                        email: account.email,
                        company_name: account.company_name
                      });
                      setEmailModalOpen(true);
                    }
                  }] : []), {
                    label: "Delete",
                    icon: <Trash2 className="w-4 h-4" />,
                    onClick: () => {
                      setAccountToDelete(account);
                      setShowDeleteDialog(true);
                    },
                    destructive: true,
                    separator: true
                  }]} />
                      </div>
                    </TableCell>
                  </TableRow>)}
            </TableBody>
          </Table>
        </div>
      </Card>

      {/* Pagination */}
      {totalPages > 0 && <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">
              Showing {filteredAccounts.length === 0 ? 0 : (currentPage - 1) * itemsPerPage + 1} to {Math.min(currentPage * itemsPerPage, filteredAccounts.length)} of {filteredAccounts.length} accounts
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))} disabled={currentPage === 1}>
              <ChevronLeft className="w-4 h-4" />
              Previous
            </Button>
            <span className="text-sm">
              Page {currentPage} of {totalPages || 1}
            </span>
            <Button variant="outline" size="sm" onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))} disabled={currentPage === totalPages || totalPages === 0}>
              Next
              <ChevronRight className="w-4 h-4" />
            </Button>
          </div>
        </div>}

      {/* Modals */}
      <AccountModal open={showModal} onOpenChange={open => {
      setShowModal(open);
      if (!open) setEditingAccount(null);
    }} account={editingAccount} onSuccess={() => {
      fetchAccounts();
      setEditingAccount(null);
    }} />

      <AccountColumnCustomizer open={showColumnCustomizer} onOpenChange={setShowColumnCustomizer} columns={localColumns} onColumnsChange={setLocalColumns} onSave={saveColumns} isSaving={isSaving} />

      <AccountDeleteConfirmDialog open={showDeleteDialog} onConfirm={handleDelete} onCancel={() => {
      setShowDeleteDialog(false);
      setAccountToDelete(null);
    }} isMultiple={false} count={1} />

      <AccountDetailModal open={showDetailModal} onOpenChange={setShowDetailModal} account={viewingAccount} onUpdate={fetchAccounts} onEdit={account => {
      setShowDetailModal(false);
      setEditingAccount(account);
      setShowModal(true);
    }} />

      <SendEmailModal open={emailModalOpen} onOpenChange={setEmailModalOpen} recipient={emailRecipient} />
    </div>;
});
AccountTable.displayName = "AccountTable";
export default AccountTable;